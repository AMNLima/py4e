Usando Banco de dados e SQL
=======================

O que é um banco de dados?
-------------------

\index{banco de dados}

Um *banco de dados* é um arquivo que é organizado para armazenar
dados. A maioria dos bancos de dados são organizados como um dicionário no sentido de
que mapeiam das chaves aos valores. A maior diferença é que o
banco de dados está no disco (ou em outro armazenamento permanente), portanto persiste
depois do programa terminar. Como um banco de dados é guardado em armazenamento permanente,
ele pode armazenar muito mais dados que um dicionário, o qual é limitado ao tamanho
da memória no computador.


\index{banco de dados!índices}

Como um dicionário, o software de banco de dados é projetado para manter a inserção
e o acesso as dados muito rápidos, mesmo para grandes quantidades.
O software de banco de dados mantém seu desempenho construindo
*índices* a medida que dados são adicionados ao banco de dados para permitir
que o computador pule rapidamente para a uma entrada específica.

Existem vários sistemas de banco de dados que são usados para uma larga
quantidade de propósitos incluindo: Oracle, MySQL, Microsoft SQL Server,
PostgreSQL, e SQLite. Focamos em SQLite nesse livro porque é um
banco de dados muito comum e já está incorporado em Python. SQLite é
desenvolvido para ser *incorporado* em outros aplicativos para prover
suporte ao banco de dados dentro do aplicativo. Por exemplo, o navegador Firefox
também usa o banco de dados SQLite internamente assim como muitos outros produtos.

<http://sqlite.org/>

SQLite é adequado para alguns dos problemas de manipulação de dados que
vemos na Informática como o aplicativo spidering do twitter que
descrevemos nesse capítulo. 

SQLite is well suited to some of the data manipulation problems that we
see in Informatics such as the Twitter spidering application that we
describe in this chapter.

Conceitos de Banco de dados
-----------------

Quando você olha pela primeira vez para um banco de dados parece como uma tabela
com várias folhas. As estruturas primárias de dados em um banco de dados são:
*tabelas*, *linhas*, e 
*colunas*.

![Relational Databases](height=2.0in@../images/relational)

Nas descrições técnicas dos bancos de dados relacionais, os conceitos de tabela,
linha, e coluna são formalmente chamadas de
*relação*, *tupla*, e *atributo*, respectivamente. Nós usaremos os termos
menos formais nesse capítulo.

Navegador de Banco de Dados para SQLite
---------------------------

Embora esse capítulo irá focar em usar Python para trabalhar com dados em
arquivos de banco de dados, várias operações podem ser feitas de maneira
mais conveniente, usando um software chamado *Navegador de Banco de Dados para SQLite*
que é disponibilizado gratuitamente em:

<http://sqlitebrowser.org/>

Usando o navegador você pode criar facilmente tabelas, inserir dados, editar dados,
ou executar consultas SQL simples nos dados do banco de dados.

Em certo sentido, o navegador de banco de dados é similar a um editor de texto
quando trabalhando com arquivos de textos. Quando você quer fazer mais de uma ou algumas
poucas operações em um arquivo de texto, você pode apenas abri-lo em um editor
e fazer as mudanças que deseja. Quando você tem muitas mudanças que precisa fazer em
um arquivo de texto, geralmente escreve um programa simples em Python. Você encontrará
o mesmo padrão quando trabalhar com banco de dados. Você fará operações simples
no gerenciador do banco de dados e operações mais complexas serão feitas
mais convenientemente em Python.

Criando uma tabela de banco de dados
-------------------------

Bancos de dados requerem estrutura mais definida do que listas ou bibliotecas Python.^[SQLite actually does allow some flexibility in the type of data
stored in a column, but we will keep our data types strict in this
chapter so the concepts apply equally to other database systems such
as MySQL.].

Quando criamos uma *tabela* de banco de dados, devemos informar antecipadamente os nomes de cada uma das *colunas* da tabela e o tipo de dados que estamos planejando armazenar em cada *coluna*. Quando o software de banco de dados conhece o tipo de dado em cada coluna, ele pode escolher a maneira mais eficiente de armazenar e procurar os dados com base no tipo de dados.

Você pode observar os vários tipos de dados suportados pelo SQLite na seguinte URL:

<http://www.sqlite.org/datatypes.html>

A definição da estrutura dos seus dados antecipadamente pode parecer inconveniente no início, mas a recompensa é o acesso rápido aos seus dados, mesmo quando o banco de dados contém uma grande quantidade de deles.

O código para criar um arquivo de banco de dados e uma tabela denominada `Tracks` com duas colunas no banco de dados é o seguinte:

\index{sqlite3 module}
\index{module!sqlite3}

\VerbatimInput{../code3/db1.py}

\index{connect function}
\index{function!connect}
\index{cursor function}
\index{function!cursor}

A operação de `connect` faz uma "conexão" com o banco de dados armazenado no arquivo `music.sqlite` no diretório atual. Se o arquivo não existir, ele será criado. O motivo pelo qual isso é chamado de "conexão" é que, às vezes, o banco de dados é armazenado em um "servidor de banco de dados" separado do servidor no qual estamos executando nosso aplicativo. Em nossos exemplos simples, o banco de dados será apenas um arquivo local no mesmo diretório que o código Python que estamos executando.

Um *cursor* é como um identificador de arquivo que podemos usar para executar operações nos dados armazenados no banco de dados. Chamar `cursor()` é muito semelhante conceitualmente a chamar `open()` ao lidar com arquivos de texto.

![A Database Cursor](height=2.0in@../images/cursor)

Uma vez que temos o cursor, podemos começar a executar comandos no conteúdo do banco de dados usando o método `execute()`.

Os comandos do banco de dados são expressos em um idioma especial que foi padronizado em muitos fornecedores diferentes para nos permitir aprender um único idioma de banco de dados. Essa linguagem é chamada de *Structured Query Language* ou *SQL*, para abreviar.

<http://en.wikipedia.org/wiki/SQL>

Em nosso exemplo, estamos executando dois comandos SQL em nosso banco de dados. Como convenção, mostraremos as palavras-chave SQL em maiúsculas e as partes do comando que estamos adicionando (como os nomes de tabela e coluna) serão mostradas em minúsculas.

O primeiro comando SQL remove a tabela `Tracks` do banco de dados, se existir. Esse padrão é simplesmente para permitir a execução do mesmo programa para criar a tabela `Tracks` repetidamente, sem causar erros. Observe que o comando `DROP TABLE` exclui a tabela e todo o seu conteúdo do banco de dados (ou seja, não há "desfazer").

~~~~ {.python}
cur.execute('DROP TABLE IF EXISTS Tracks ')
~~~~

O segundo comando cria uma tabela chamada `Tracks` com uma coluna de texto chamada `title` e uma coluna inteira chamada `plays`.

~~~~ {.python}
cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
~~~~

Agora que criamos uma tabela chamada `Tracks`, podemos colocar alguns dados nessa tabela usando a operação SQL `INSERT`. Novamente, começamos fazendo uma conexão com o banco de dados e obtendo o `cursor`. Podemos então executar comandos SQL usando o cursor.

O comando SQL `INSERT` indica qual tabela estamos usando e, em seguida, define uma nova linha listando os campos que queremos incluir `(title, plays)` seguidos pelos `VALUES` que queremos que sejam colocados na nova linha. Especificamos os valores como pontos de interrogação `(?, ?)` Para indicar que os valores reais são passados como uma tupla `( 'My Way', 15 )` como o segundo parâmetro para a chamada `execute()`.

\VerbatimInput{../code3/db2.py}

Primeiro, nós utilizamos `INSERT` para duas linhas em nossa tabela e usamos `commit()` para forçar os dados a serem gravados no arquivo de banco de dados.

![Rows in a Table](height=1.5in@../images/tracks)

Em seguida, usamos o comando `SELECT` para recuperar as linhas que acabamos de inserir da tabela. No comando `SELECT`, indicamos de quais colunas gostaríamos `(title, plays)` e de qual tabela queremos recuperar os dados. Depois de executar a instrução `SELECT`, o cursor é algo pelo qual podemos percorrer uma instrução `for`. Por questões de eficiência, o cursor não lê todos os dados do banco de dados quando executamos a instrução `SELECT`. Em vez disso, os dados são lidos sob demanda, conforme percorremos as linhas na instrução `for`.

A saída do programa é a seguinte:

~~~~
Tracks:
('Thunderstruck', 20)
('My Way', 15)
~~~~

\index{Unicode}

Nosso loop `for` são encontradas duas linhas, e cada linha é uma tupla Python com o primeiro valor como o `title` e o segundo valor como o número de `plays`.

*Nota: Você pode ver cadeias começando com `u'` em outros livros ou na Internet. Essa foi uma indicação no Python 2 de que as strings são strings Unicode capazes de armazenar conjuntos de caracteres não latinos. No Python 3, todas as strings são unicode por padrão.

No final do programa, executamos um comando SQL para `DELETE` as linhas que acabamos de criar, para que possamos executar o programa repetidamente. O comando `DELETE` mostra o uso de uma cláusula `WHERE` que nos permite expressar um critério de seleção para que possamos solicitar ao banco de dados que aplique o comando apenas às linhas que correspondem ao critério. Neste exemplo, o critério se aplica a todas as linhas, de modo que esvaziamos a tabela para que possamos executar o programa repetidamente. Depois que o `DELETE` é executado, também chamamos `commit()` para forçar os dados a serem removidos do banco de dados.

Resumo da Structured Query Language
---------------------------------

Até o momento, usamos a Structured Query Language em nossos exemplos de Python e cobrimos muitos dos princípios básicos dos comandos SQL. Nesta seção, examinamos a linguagem SQL em particular e fornecemos uma visão geral da sintaxe SQL.

Como existem muitos fornecedores diferentes de banco de dados, a Structured Query Language (SQL) foi padronizada para que pudéssemos nos comunicar de maneira portátil aos sistemas de banco de dados de vários fornecedores.

Um banco de dados relacional é composto de tabelas, linhas e colunas. As colunas geralmente têm um tipo como texto, dados numéricos ou de data. Quando criamos uma tabela, indicamos os nomes e tipos das colunas:

~~~~ {.sql}
CREATE TABLE Tracks (title TEXT, plays INTEGER)
~~~~

Para inserir uma linha em uma tabela, usamos o comando SQL `INSERT`:


~~~~ {.sql}
INSERT INTO Tracks (title, plays) VALUES ('My Way', 15)
~~~~

A instrução `INSERT` especifica o nome da tabela, uma lista dos campos / colunas que você deseja definir na nova linha e, em seguida, a palavra-chave `VALUES` e uma lista dos valores correspondentes para cada um dos campos.


O comando SQL `SELECT` é usado para recuperar linhas e colunas de um banco de dados. A instrução `SELECT` permite especificar quais colunas você gostaria de recuperar, bem como uma cláusula `WHERE` para selecionar quais linhas você gostaria de ver. Ele também permite que uma cláusula `ORDER BY` opcional controle a classificação das linhas retornadas.


~~~~ {.sql}
SELECT * FROM Tracks WHERE title = 'My Way'
~~~~

Usar `*` indica que você deseja que o banco de dados retorne todas as colunas para cada linha que corresponda à cláusula `WHERE`.

Observe que, diferentemente do Python, em uma cláusula SQL `WHERE` usamos um único sinal de igual para indicar um teste de igualdade em vez de um duplo sinal de igual. Outras operações lógicas permitidas em uma cláusula WHERE incluem `<`, `>`, `<=`, `>=`, `!=`, Além de `AND` e `OR` e parênteses para construir suas expressões lógicas.

Você pode solicitar que as linhas retornadas sejam classificadas por um dos campos da seguinte maneira:

~~~~ {.sql}
SELECT title,plays FROM Tracks ORDER BY title
~~~~

Para remover uma linha, você precisa de uma cláusula `WHERE` em uma instrução SQL `DELETE`. A cláusula `WHERE` determina quais linhas devem ser excluídas:

~~~~ {.sql}
DELETE FROM Tracks WHERE title = 'My Way'
~~~~

É possível `UPDATE` uma coluna ou colunas dentro de uma ou mais linhas em uma tabela usando a instrução SQL `UPDATE` da seguinte maneira:

~~~~ {.sql}
UPDATE Tracks SET plays = 16 WHERE title = 'My Way'
~~~~

A instrução `UPDATE` especifica uma tabela e, em seguida, uma lista de campos e valores a serem alterados após a palavra-chave `SET` e, em seguida, uma cláusula `WHERE` opcional para selecionar as linhas que devem ser atualizadas. Uma única instrução `UPDATE` poderá alterar todas as linhas que correspondem à cláusula `WHERE`. Se uma cláusula `WHERE` não for especificada, ela executará o `UPDATE` em todas as linhas da tabela

Esses quatro comandos SQL básicos (INSERT, SELECT, UPDATE e DELETE) permitem as quatro operações básicas necessárias para criar e manter dados.


Spidering Twitter using a database
----------------------------------

In this section, we will create a simple spidering program that will go
through Twitter accounts and build a database of them. *Note: Be very
careful when running this program. You do not want to pull too much data
or run the program for too long and end up having your Twitter access
shut off.*

One of the problems of any kind of spidering program is that it needs to
be able to be stopped and restarted many times and you do not want to
lose the data that you have retrieved so far. You don't want to always
restart your data retrieval at the very beginning so we want to store
data as we retrieve it so our program can start back up and pick up
where it left off.

We will start by retrieving one person's Twitter friends and their
statuses, looping through the list of friends, and adding each of the
friends to a database to be retrieved in the future. After we process
one person's Twitter friends, we check in our database and retrieve one
of the friends of the friend. We do this over and over, picking an
"unvisited" person, retrieving their friend list, and adding friends we
have not seen to our list for a future visit.

We also track how many times we have seen a particular friend in the
database to get some sense of their "popularity".

By storing our list of known accounts and whether we have retrieved the
account or not, and how popular the account is in a database on the disk
of the computer, we can stop and restart our program as many times as we
like.

This program is a bit complex. It is based on the code from the exercise
earlier in the book that uses the Twitter API.

Here is the source code for our Twitter spidering application:

\VerbatimInput{../code3/twspider.py}

Our database is stored in the file `spider.sqlite3` and it
has one table named `Twitter`. Each row in the
`Twitter` table has a column for the account name, whether we
have retrieved the friends of this account, and how many times this
account has been "friended".

In the main loop of the program, we prompt the user for a Twitter
account name or "quit" to exit the program. If the user enters a Twitter
account, we retrieve the list of friends and statuses for that user and
add each friend to the database if not already in the database. If the
friend is already in the list, we add 1 to the `friends`
field in the row in the database.

If the user presses enter, we look in the database for the next Twitter
account that we have not yet retrieved, retrieve the friends and
statuses for that account, add them to the database or update them, and
increase their `friends` count.

Once we retrieve the list of friends and statuses, we loop through all
of the `user` items in the returned JSON and retrieve the
`screen_name` for each user. Then we use the `SELECT`
statement to see if we already have stored this particular `screen_name`
in the database and retrieve the friend count (`friends`) if
the record exists.

~~~~ {.python}
countnew = 0
countold = 0
for u in js['users'] :
    friend = u['screen_name']
    print(friend)
    cur.execute('SELECT friends FROM Twitter WHERE name = ? LIMIT 1',
        (friend, ) )
    try:
        count = cur.fetchone()[0]
        cur.execute('UPDATE Twitter SET friends = ? WHERE name = ?',
            (count+1, friend) )
        countold = countold + 1
    except:
        cur.execute('''INSERT INTO Twitter (name, retrieved, friends)
            VALUES ( ?, 0, 1 )''', ( friend, ) )
        countnew = countnew + 1
print('New accounts=',countnew,' revisited=',countold)
conn.commit()
~~~~

Once the cursor executes the `SELECT` statement, we must
retrieve the rows. We could do this with a `for` statement,
but since we are only retrieving one row (`LIMIT 1`), we can
use the `fetchone()` method to fetch the first (and only) row
that is the result of the `SELECT` operation. Since
`fetchone()` returns the row as a *tuple*
(even though there is only one field), we take the first value from the
tuple using to get the current friend count into the variable
`count`.

If this retrieval is successful, we use the SQL `UPDATE`
statement with a `WHERE` clause to add 1 to the
`friends` column for the row that matches the friend's
account. Notice that there are two placeholders (i.e., question marks)
in the SQL, and the second parameter to the `execute()` is a
two-element tuple that holds the values to be substituted into the SQL
in place of the question marks.

If the code in the `try` block fails, it is probably because
no record matched the `WHERE name = ?` clause on the SELECT
statement. So in the `except` block, we use the SQL
`INSERT` statement to add the friend's `screen_name` to the
table with an indication that we have not yet retrieved the
`screen_name` and set the friend count to zero.

So the first time the program runs and we enter a Twitter account, the
program runs as follows:

~~~~
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit: quit
~~~~

Since this is the first time we have run the program, the database is
empty and we create the database in the file `spider.sqlite3`
and add a table named `Twitter` to the database. Then we
retrieve some friends and add them all to the database since the
database is empty.

At this point, we might want to write a simple database dumper to take a
look at what is in our `spider.sqlite3` file:

\VerbatimInput{../code3/twdump.py}

This program simply opens the database and selects all of the columns of
all of the rows in the table `Twitter`, then loops through
the rows and prints out each row.

If we run this program after the first execution of our Twitter spider
above, its output will be as follows:

~~~~
('opencontent', 0, 1)
('lhawthorn', 0, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
20 rows.
~~~~

We see one row for each `screen_name`, that we have not retrieved the
data for that `screen_name`, and everyone in the database has one
friend.

Now our database reflects the retrieval of the friends of our first
Twitter account (*drchuck*). We can run the program again
and tell it to retrieve the friends of the next "unprocessed" account by
simply pressing enter instead of a Twitter account as follows:

~~~~
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 18  revisited= 2
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
~~~~

Since we pressed enter (i.e., we did not specify a Twitter account), the
following code is executed:

~~~~ {.python}
if ( len(acct) < 1 ) :
    cur.execute('SELECT name FROM Twitter WHERE retrieved = 0 LIMIT 1')
    try:
        acct = cur.fetchone()[0]
    except:
        print('No unretrieved twitter accounts found')
        continue
~~~~

We use the SQL `SELECT` statement to retrieve the name of the
first (`LIMIT 1`) user who still has their "have we retrieved
this user" value set to zero. We also use the `fetchone()[0]`
pattern within a try/except block to either extract a `screen_name` from
the retrieved data or put out an error message and loop back up.

If we successfully retrieved an unprocessed `screen_name`, we retrieve
their data as follows:

~~~~ {.python}
url=twurl.augment(TWITTER_URL,{'screen_name': acct,'count': '20'})
print('Retrieving', url)
connection = urllib.urlopen(url)
data = connection.read()
js = json.loads(data)

cur.execute('UPDATE Twitter SET retrieved=1 WHERE name = ?',(acct, ))
~~~~

Once we retrieve the data successfully, we use the `UPDATE`
statement to set the `retrieved` column to 1 to indicate that
we have completed the retrieval of the friends of this account. This
keeps us from retrieving the same data over and over and keeps us
progressing forward through the network of Twitter friends.

If we run the friend program and press enter twice to retrieve the next
unvisited friend's friends, then run the dumping program, it will give
us the following output:

~~~~
('opencontent', 1, 1)
('lhawthorn', 1, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
('cnxorg', 0, 2)
('knoop', 0, 1)
('kthanos', 0, 2)
('LectureTools', 0, 1)
...
55 rows.
~~~~

We can see that we have properly recorded that we have visited
`lhawthorn` and `opencontent`. Also the accounts
`cnxorg` and `kthanos` already have two followers.
Since we now have retrieved the friends of three people
(`drchuck`, `opencontent`, and
`lhawthorn`) our table has 55 rows of friends to retrieve.

Each time we run the program and press enter it will pick the next
unvisited account (e.g., the next account will be `steve_coppin`),
retrieve their friends, mark them as retrieved, and for each of the
friends of `steve_coppin` either add them to the end of the database or
update their friend count if they are already in the database.

Since the program's data is all stored on disk in a database, the
spidering activity can be suspended and resumed as many times as you
like with no loss of data.

Basic data modeling
-------------------

The real power of a relational database is when we create multiple
tables and make links between those tables. The act of deciding how to
break up your application data into multiple tables and establishing the
relationships between the tables is called *data
modeling*. The design document that shows the tables and their
relationships is called a *data model*.

Data modeling is a relatively sophisticated skill and we will only
introduce the most basic concepts of relational data modeling in this
section. For more detail on data modeling you can start with:

<http://en.wikipedia.org/wiki/Relational_model>

Let's say for our Twitter spider application, instead of just counting a
person's friends, we wanted to keep a list of all of the incoming
relationships so we could find a list of everyone who is following a
particular account.

Since everyone will potentially have many accounts that follow them, we
cannot simply add a single column to our `Twitter` table. So
we create a new table that keeps track of pairs of friends. The
following is a simple way of making such a table:

~~~~ {.sql}
CREATE TABLE Pals (from_friend TEXT, to_friend TEXT)
~~~~

Each time we encounter a person who `drchuck` is following,
we would insert a row of the form:

~~~~ {.sql}
INSERT INTO Pals (from_friend,to_friend) VALUES ('drchuck', 'lhawthorn')
~~~~

As we are processing the 20 friends from the `drchuck`
Twitter feed, we will insert 20 records with "drchuck" as the first
parameter so we will end up duplicating the string many times in the
database.

This duplication of string data violates one of the best practices for
*database normalization* which basically states that we
should never put the same string data in the database more than once. If
we need the data more than once, we create a numeric
*key* for the data and reference the actual data using
this key.

In practical terms, a string takes up a lot more space than an integer
on the disk and in the memory of our computer, and takes more processor
time to compare and sort. If we only have a few hundred entries, the
storage and processor time hardly matters. But if we have a million
people in our database and a possibility of 100 million friend links, it
is important to be able to scan data as quickly as possible.

We will store our Twitter accounts in a table named `People`
instead of the `Twitter` table used in the previous example.
The `People` table has an additional column to store the
numeric key associated with the row for this Twitter user. SQLite has a
feature that automatically adds the key value for any row we insert into
a table using a special type of data column (`INTEGER PRIMARY
KEY`).

We can create the `People` table with this additional
`id` column as follows:

~~~~ {.sql}
CREATE TABLE People
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)
~~~~

Notice that we are no longer maintaining a friend count in each row of
the `People` table. When we select `INTEGER PRIMARY
KEY` as the type of our `id` column, we are indicating
that we would like SQLite to manage this column and assign a unique
numeric key to each row we insert automatically. We also add the keyword
`UNIQUE` to indicate that we will not allow SQLite to insert
two rows with the same value for `name`.

Now instead of creating the table `Pals` above, we create a
table called `Follows` with two integer columns `from_id` and
`to_id` and a constraint on the table that the *combination* of
`from_id` and `to_id` must be unique in this table (i.e., we cannot
insert duplicate rows) in our database.

~~~~ {.sql}
CREATE TABLE Follows
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id) )
~~~~

When we add `UNIQUE` clauses to our tables, we are
communicating a set of rules that we are asking the database to enforce
when we attempt to insert records. We are creating these rules as a
convenience in our programs, as we will see in a moment. The rules both
keep us from making mistakes and make it simpler to write some of our
code.

In essence, in creating this `Follows` table, we are
modelling a "relationship" where one person "follows" someone else and
representing it with a pair of numbers indicating that (a) the people
are connected and (b) the direction of the relationship.

![Relationships Between Tables](height=3.5in@figs2/twitter)

Programming with multiple tables
--------------------------------

We will now redo the Twitter spider program using two tables, the
primary keys, and the key references as described above. Here is the
code for the new version of the program:

\VerbatimInput{../code3/twfriends.py}

This program is starting to get a bit complicated, but it illustrates
the patterns that we need to use when we are using integer keys to link
tables. The basic patterns are:

1.  Create tables with primary keys and constraints.

2.  When we have a logical key for a person (i.e., account name) and we
    need the `id` value for the person, depending on whether
    or not the person is already in the `People` table we
    either need to: (1) look up the person in the `People`
    table and retrieve the `id` value for the person or (2)
    add the person to the `People` table and get the
    `id` value for the newly added row.

3.  Insert the row that captures the "follows" relationship.

We will cover each of these in turn.

### Restrições em tabelas do banco de dados

A medida que planejamos a estrutura de nossa tabela, podemos dizer ao sistema de banco de dados que gostaríamos que ele nos impusesse algumas regras. Essas regras evitam que possamos cometer erros e que dados incorretos sejam introduzidos nas tabelas. Quando criamos nossas tabelas:

~~~~ {.python}
cur.execute('''CREATE TABLE IF NOT EXISTS People
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Follows
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))''')
~~~~


Indicamos que a coluna `nome` na tabela `Pessoas` precisa ser `UNIQUE`. Nós também indicamos que a combinação dos dois números em cada linha da tabela `Segue` deve ser única. Essas restrições nos impedem de cometer o erro de adicionar a mesma relação mais de uma vez. 

Podemos nos aproveitar dessas restrições no código a seguir:

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
    VALUES ( ?, 0)''', ( friend, ) )
~~~~

Podemos adicionar a cláusula `OR IGNORE` à declaração `INSERT` para indicar que caso este `INSERT` em particular venha a causar uma violação da regra “`nome` deve ser único“, o sistema de banco de dados está autorizado a ignorar o `INSERT`. Assim, estamos usando as restrições do banco de dados como um filtro de segurança, garantindo que não iremos fazer algo errado inadvertidamente. 

De forma similar, o código a seguir assegura que não adicionaremos a mesma relação `Segue` mais de uma vez.  

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO Follows
    (from_id, to_id) VALUES (?, ?)''', (id, friend_id) )
~~~~

Novamente, apenas dizemos ao banco de dados para ignorar a tentativa `INSERT` caso ela viole a restrição de singularidade que especificamos para as linhas de `Segue`. 


### Recuperar e/ou inserir um registro

Quando requisitamos ao usuário uma conta do Twitter, se a conta existir, devemos procurar seu valor `id`. Se a conta não existir na tabela `Pessoas`, devemos inserir um registro e guardar o valor `id` da linha inserida.

Este é um padrão muito comum e feito duas vezes no programa abaixo. O código mostra como procuramos pelo `id` da conta de um amigo, quando tivermos extraído o `screen_name` do `usuário` presente no Twitter JSON recuperado. 

Já que ao longo do tempo há uma maior chance da conta constar no banco de dados, primeiro verificamos se o registro em `Pessoas` existe, usando a declaração `SELECT`. 

Se tudo ocorrer bem^[Em geral, quando a frase começar com “se tudo ocorrer bem”, você perceberá que o código precisa de um bloco try/except.] dentro da seção `try`, devemos recuperar o registro usando `fetchone()` e então retirar o primeiro (e apenas o primeiro) elemento da tupla obtida e armazená-la em `amigo_id`.

Caso SELECT `resulte` em falha, o código `fetchone()[0]` irá falhar e o controlador executará a seção `except`.

~~~~ {.python}
    friend = u['screen_name']
    cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1',
        (friend, ) )
    try:
        friend_id = cur.fetchone()[0]
        countold = countold + 1
    except:
        cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
            VALUES ( ?, 0)''', ( friend, ) )
        conn.commit()
        if cur.rowcount != 1 :
            print('Error inserting account:',friend)
            continue
        friend_id = cur.lastrowid
        countnew = countnew + 1
~~~~

Caso o código `except` seja executado, apenas significa que a linha não foi encontrada e, portanto, deve ser inserida. Usamos `INSERT OR IGNORE` para evitar erros e então chamar `commit()` para forçar o banco de dados a ser atualizado. Depois da escrita ter sido feita, podemos verificar o `cur_rowcount` para ver quantas linhas foram afetadas. Já que estamos tentando inserir uma única linha, se o número de linhas afetados for diferente de 1, houve um erro. 

No entanto, se o `INSERT` for bem-sucedido, `cur_lastrowid` pode ser avaliado para encontrar o valor na coluna `id`, atribuído pelo banco de dados, da nova linha.

### Storing the friend relationship

Uma vez que sabemos o valor chave para tanto o usuário do Twitter quanto seu amigo, no JSON, basta inserirmos os dois números na tabela `Segue` com o código abaixo:

~~~~ {.python}
cur.execute('INSERT OR IGNORE INTO Follows (from_id, to_id) VALUES (?, ?)',
    (id, friend_id) )
~~~~

Note que encarregamos o banco de dados de nos prevenir de inserir duas vezes uma relação. Isto se dá ao criarmos uma tabela com a restrição de singularidade e então adicionando `OR IGNORE` à declaração `INSERT`.

Aqui está um exemplo da execução deste programa: 

~~~~
Enter a Twitter account, or quit:
No unretrieved Twitter accounts found
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
~~~~

Começamos com a conta `drchuck` e então deixamos o programa automaticamente selecionar as duas contas a serem obtidas e adicionadas ao nosso banco de dados.

Abaixo estão as primeiras linhas para as tabelas `Pessoas` e `Segue`, após a execução ser finalizada: 

~~~~
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
~~~~

Você pode ver os campos `id`, `nome` e `visitado` na tabela `Pessoas`, bem como os números em ambas as pontas da relação na tabela `Segue`. Na tabela `Pessoas`, vemos que as três primeiras pessoas foram visitadas e suas informações foram obtidas. Os dados na tabela `Segue` indicam que `drchuck` (usuário 1) é amigo de todas as pessoas nas primeiras 5 linhas. Isto faz sentido já que o primeiro conjunto de informações recuperado e armazenado foi referente aos amigos de `drchuck`. Se desejasse imprimir mais linhas da tabela `Segue`, também veria os amigos dos usuários 2 e 3.


Three kinds of keys
-------------------

Now that we have started building a data model putting our data into
multiple linked tables and linking the rows in those tables using
*keys*, we need to look at some terminology around keys.
There are generally three kinds of keys used in a database model.

-   A *logical key* is a key that the "real world" might
    use to look up a row. In our example data model, the
    `name` field is a logical key. It is the screen name for
    the user and we indeed look up a user's row several times in the
    program using the `name` field. You will often find that
    it makes sense to add a `UNIQUE` constraint to a logical
    key. Since the logical key is how we look up a row from the outside
    world, it makes little sense to allow multiple rows with the same
    value in the table.

-   A *primary key* is usually a number that is assigned
    automatically by the database. It generally has no meaning outside
    the program and is only used to link rows from different tables
    together. When we want to look up a row in a table, usually
    searching for the row using the primary key is the fastest way to
    find the row. Since primary keys are integer numbers, they take up
    very little storage and can be compared or sorted very quickly. In
    our data model, the `id` field is an example of a primary
    key.

-   A *foreign key* is usually a number that points to
    the primary key of an associated row in a different table. An
    example of a foreign key in our data model is the `from_id`.

We are using a naming convention of always calling the primary key field
name `id` and appending the suffix `_id` to any field name
that is a foreign key.

Using JOIN to retrieve data
---------------------------

Now that we have followed the rules of database normalization and have
data separated into two tables, linked together using primary and
foreign keys, we need to be able to build a `SELECT` that
reassembles the data across the tables.

SQL uses the `JOIN` clause to reconnect these tables. In the
`JOIN` clause you specify the fields that are used to
reconnect the rows between the tables.

The following is an example of a `SELECT` with a
`JOIN` clause:

~~~~ {.sql}
SELECT * FROM Follows JOIN People
    ON Follows.from_id = People.id WHERE People.id = 1
~~~~

The `JOIN` clause indicates that the fields we are selecting
cross both the `Follows` and `People` tables. The
`ON` clause indicates how the two tables are to be joined:
Take the rows from `Follows` and append the row from
`People` where the field `from_id` in `Follows` is
the same the `id` value in the `People` table.

![Connecting Tables Using JOIN](height=3.5in@figs2/join)

The result of the JOIN is to create extra-long "metarows" which have
both the fields from `People` and the matching fields from
`Follows`. Where there is more than one match between the
`id` field from `People` and the `from_id` from
`People`, then JOIN creates a metarow for *each* of the
matching pairs of rows, duplicating data as needed.

The following code demonstrates the data that we will have in the
database after the multi-table Twitter spider program (above) has been
run several times.

\VerbatimInput{../code3/twjoin.py}

In this program, we first dump out the `People` and
`Follows` and then dump out a subset of the data in the
tables joined together.

Here is the output of the program:

~~~~
python twjoin.py
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
Connections for id=2:
(2, 1, 1, 'drchuck', 1)
(2, 28, 28, 'cnxorg', 0)
(2, 30, 30, 'kthanos', 0)
(2, 102, 102, 'SomethingGirl', 0)
(2, 103, 103, 'ja_Pac', 0)
20 rows.
~~~~

You see the columns from the `People` and
`Follows` tables and the last set of rows is the result of
the `SELECT` with the `JOIN` clause.

In the last select, we are looking for accounts that are friends of
"opencontent" (i.e., `People.id=2`).

In each of the "metarows" in the last select, the first two columns are
from the `Follows` table followed by columns three through
five from the `People` table. You can also see that the
second column (`Follows.to_id`) matches the third column
(`People.id`) in each of the joined-up "metarows".

Sumário
-------

Esse capítulo englobou muito assunto para te dar uma visão geral do basico
sobre como usar base de dados em Python. É mais complicado escrever o 
código para usar a base de dados para guardar os dados que dicionários em 
Python ou arquivos simples então existe uma pequena razão para usar banco de
dados a não ser que sua aplicação realmente precise das capacidades de um banco
de dados. As situações que um banco de dados pode ser útil são: (1) quando sua
aplicação precisa fazer pequenas atualizações aleatórias em um grande conjunto de
dados, (2) quando seus dados são tão grandes que não se encaixam num dicionário
e você precisa analisar as informações repetidamente, ou (3) quando você tem
um processo de longa duração que você é capaz de parar e reiniciar e manter as 
informações de uma inicialização para a outra.

Você pode construir uma simples base de dados com uma única tabela para 
satisfazer as necessidades da aplicação, mas várias aplicações exigirão várias
tabelas e conexões/relações entre linhas em diferentes tabelas. Quando começar 
a fazer conexões entre tabelas, é importante fazer um projeto mais pensado e 
seguir as regras de normalização de base de dados para fazer melhor uso das suas
capacidades. Visto que a principal motivação para usar um banco de dados é que 
tem-se uma grande quantidade de dados para lidar, é importante categorizar seus 
dados de maneira eficiente então seu programa funcionará o mais rápido possível.

Depurando
---------

Um padrão comum quando você está desenvolvendo um programa Python para
conexão de uma base de dados SQLite será a de iniciar o programa e 
conferir osresultados usando o navegador de banco de dados pro SQLite.
O navegador te permite verificar rapidamente se o programa está 
funcionando corretamente.

Você precisa ter cuidado pois SQLite se certifica de evitar dois programas
de modificar o mesmo dado ao mesmo tempo. Por exemplo, se você abrir o
banco de dados no navegador e modificá-lo, porém não presionar o botão 
"salvar" ainda, o navegador "trava" o arquivo do banco de dados e evita 
qualquer outro programa de acessar o arquivo. Em particular, seu programa
Python não será capaz de acessar o arquivo se ele estiver bloqueado.

Então a solução é ter certeza de fechar o navegador do banco de dados
ou usar o menu *Arquivo* para fechar o banco de dados no navegador antes 
de tentar acessar a base de dados pelo Python para evitar o problema do
código falhar por causa do banco de dados estar bloqueado.

Glossário
--------

atributo
:   Um dos valores da tupla. Mais comumente chamado de "coluna" ou 
    "campo".
\index{attribute}

restrição
:   Quando chamamos o banco de dados para import uma regra num campo ou 
    numa linha numa tabela. Uma regra comum é restringir que não possa haver valores duplicados num campo em particular (i.e., todos os valores devem ser únicos).
\index{constraint}

cursor
:   O cursor te permite executar comandos SQL no banco de dados e 
    recuperar dados do mesmo. O cursor é similar com o socket ou 
    o identificaor de arquivo das conexões de internet e arquivos,
    respectivamente.
\index{cursor}

navegador de banco de dados
:   *Software* que te permite se conectar diretamente com o banco de dados
    e manipulá-lo diretamente sem escrever um programa.
\index{database browser}

chave externa
:   Uma chave numérica que aponta para a primeira chave de uma linha de
    outra tabela. Chaves externas estabelecem relações entre linhas
    armazenadas em tabelas diferentes.
\index{foreign key}

índice
:   Dado adicional que o *software* do banco de dados conserva como linhas
    e adiciona na tabela pra facilitar acelerar a cisualização dos dados.
\index{index}
\index{}

chave lógica
:   A chave que o "mundo externo" usa para visualizar uma linha em 
    particular. Por exemplo em uma tabela de contas de usuários, o email
    de uma pessoa poderia ser um ótimo candidato a ser uma chave lógica
    para os dados do usuário.
    \index{logical key}

normalização
:   modelar os dados para que não haja réplicas. Guarda-se cada ítem dos
    dados em um local no banco de dados e faz-se referência dele em outro
    lugar utilizando uma chave externa.
\index{normalization}
\index{database normalization}

chave primária
:   Uma chave numérica atribuída a cada linha é utilizada para se 
    referenciar uma linha na tabela por meio de outra tabela. Usualmente 
    os bancos de dados são configurados para atribuir automaticamente 
    chaves primárias assim que linhas são inseridas.
\index{primary key}

relação
:   Uma área no banco de dados que contém tuplas e atributos. Mais 
    comumente chamada como "tabela".
\index{relation}

tupla
:   Uma entrada simples numa tabela do banco de dados que é um conjunto 
    de atributos. Mais comumente chamada como "linha".
\index{tuple}

